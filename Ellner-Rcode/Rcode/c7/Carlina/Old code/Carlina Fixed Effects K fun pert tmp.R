## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Fit and run fixed and mixed effects effects Carlina stochastic IPM
## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

rm(list=ls(all=TRUE))

library(doBy)
library(lme4)
library(MCMCglmm)
set.seed(53241986)

## Working directory must be set here, so the source()'s below run
root=ifelse(.Platform$OS.type=="windows","c:/repos","~/Repos"); 
setwd(paste(root,"/ipm_book/Rcode/c2",sep="")); 

source("../utilities/Standard Graphical Pars.R");

root=ifelse(.Platform$OS.type=="windows","c:/repos","~/Repos"); 
setwd(paste(root,"/ipm_book/Rcode/c7/Carlina",sep="")); 

#Read in the Carlina demographic data
load("CarlinaIBMsim.Rdata")
str(sim.data)

store.sim.data <- sim.data

#Select recruit data for the last 20 years (years 31 to 50)
recr.data <- subset(sim.data,Recr==1)
recr.data <- subset(recr.data,Yeart>30)
recr.data <- transform(recr.data,Yeart = factor(Yeart - 30))

#plant data for years 30 to 49, we do this to as the recruit size in 
#year t was generated by the year t-1 parameters
sim.data <- subset(sim.data,Yeart>29 & Yeart<50)
with(sim.data,table(Yeart,Recr))
#Make Yeart a factor
sim.data <- transform(sim.data,Yeart = factor(Yeart - 29))


#fit some survival models

mod.Surv <- glm(Surv ~ Yeart  , family = binomial, data = sim.data)
mod.Surv.1 <- glm(Surv ~ Yeart + z  , family = binomial, data = sim.data)
mod.Surv.2 <- glm(Surv ~ Yeart * z  , family = binomial, data = sim.data)

anova(mod.Surv,mod.Surv.1,mod.Surv.2,test="Chisq")
AIC(mod.Surv,mod.Surv.1,mod.Surv.2)

#there is evidence of an interaction, as we might expect as both the intercept and slope vary from 
#year to year

#Let's refit so we can easily get the parameter estimates

mod.Surv <- glm(Surv ~ Yeart/ z -1 , family = binomial, data = sim.data)

summary(mod.Surv)

#Let's refit using glmer

mod.Surv.glmer   <- glmer(Surv ~ 1 + (1|Yeart)  , family = binomial, data = sim.data)
mod.Surv.glmer.1 <- glmer(Surv ~ z + (1|Yeart)  , family = binomial, data = sim.data)
mod.Surv.glmer.2 <- glmer(Surv ~ z + (1|Yeart) + (0 + z|Yeart)  , family = binomial, data = sim.data)
mod.Surv.glmer.3 <- glmer(Surv ~ z + (z|Yeart)  , family = binomial, data = sim.data)
anova(mod.Surv.glmer,mod.Surv.glmer.1,mod.Surv.glmer.2,mod.Surv.glmer.3)



# # d<-1
# prior=list(R=list(V=1, fix=1), G=list(G1=list(V=diag(d), nu=d, alpha.mu=rep(0,d), alpha.V=diag(d)*1000)))

# mod.Surv.MCMC   <- MCMCglmm(Surv ~ 1, random=~Yeart  , family = "categorical", data = sim.data,
# slice=TRUE, pr=TRUE,prior=prior)

# mod.Surv.MCMC.1   <- MCMCglmm(Surv ~ z, random=~Yeart  , family = "categorical", data = sim.data,
# slice=TRUE, pr=TRUE,prior=prior)

# d<-2
# prior=list(R=list(V=1, fix=1), G=list(G1=list(V=diag(d), nu=d, alpha.mu=rep(0,d), alpha.V=diag(d)*1000)))

# mod.Surv.MCMC.2  <- MCMCglmm(Surv ~ z, random=~idh(1+z):Yeart  , family = "categorical", data = sim.data,
# slice=TRUE, pr=TRUE,prior=prior)

# mod.Surv.MCMC.3   <- MCMCglmm(Surv ~ z, random=~us(1+z):Yeart  , family = "categorical", data = sim.data,
# slice=TRUE, pr=TRUE,prior=prior)

# post.modes <- posterior.mode(mod.Surv.MCMC.2$Sol)

# intercepts.MCMC <- post.modes["(Intercept)"] + post.modes[3:22]

# slopes.MCMC <- post.modes["z"] + post.modes[23:42]

# par(mfrow=c(1,2),bty="l",pty="s",pch=19)

# plot(intercepts.MCMC,coef(mod.Surv.glmer.2)$Yeart[,"(Intercept)"])
# abline(0,1,col="red")
# plot(slopes.MCMC,coef(mod.Surv.glmer.2)$Yeart[,"z"])
# abline(0,1,col="red")


#fit some flowering models

flow.data <- subset(sim.data,Surv==1)

mod.Flow <- glm(Flow ~ Yeart  , family = binomial, data = flow.data)
mod.Flow.1 <- glm(Flow ~ Yeart + z  , family = binomial, data = flow.data)
mod.Flow.2 <- glm(Flow ~ Yeart * z  , family = binomial, data = flow.data)

anova(mod.Flow,mod.Flow.1,mod.Flow.2,test="Chisq")
AIC(mod.Flow,mod.Flow.1,mod.Flow.2)

#No interaction term, as expected, refit to get paramter estimates easily

mod.Flow <- glm(Flow ~ Yeart + z -1 , family = binomial, data = flow.data)

#Let's refit using glmer

mod.Flow.glmer   <- glmer(Flow ~ 1 + (1|Yeart)  , family = binomial, data = flow.data)
mod.Flow.glmer.1 <- glmer(Flow ~ z + (1|Yeart)  , family = binomial, data = flow.data)
mod.Flow.glmer.2 <- glmer(Flow ~ z + (1|Yeart) + (0 + z|Yeart)  , family = binomial, data = flow.data)
mod.Flow.glmer.3 <- glmer(Flow ~ z + (z|Yeart)  , family = binomial, data = flow.data)
anova(mod.Flow.glmer,mod.Flow.glmer.1,mod.Flow.glmer.2,mod.Flow.glmer.3)

#fit some growth models

grow.data <- subset(sim.data,Surv==1 & Flow==0)

mod.Grow <- lm(z1 ~ Yeart  , data = grow.data)
mod.Grow.1 <- lm(z1 ~ Yeart +z , data = grow.data)
mod.Grow.2 <- lm(z1 ~ Yeart *z , data = grow.data)

anova(mod.Grow,mod.Grow.1,mod.Grow.2)
AIC(mod.Grow,mod.Grow.1,mod.Grow.2)

mod.Grow <- lm(z1 ~ Yeart/z-1  , data = grow.data)

#Let's refit using lmer

mod.Grow.lmer   <- lmer(z1 ~ 1 + (1|Yeart)  ,  data = grow.data, REML=FALSE)
mod.Grow.lmer.1 <- lmer(z1 ~ z + (1|Yeart)  ,  data = grow.data, REML=FALSE)
mod.Grow.lmer.2 <- lmer(z1 ~ z + (1|Yeart) + (0 + z|Yeart)  ,  data = grow.data, REML=FALSE)
mod.Grow.lmer.3 <- lmer(z1 ~ z + (z|Yeart)  ,  data = grow.data, REML=FALSE)
anova(mod.Grow.lmer,mod.Grow.lmer.1,mod.Grow.lmer.2,mod.Grow.lmer.3)

#fit some recruit size models

mod.Rcsz <- lm(z ~ 1  , data = recr.data)
mod.Rcsz.1 <- lm(z ~ Yeart , data = recr.data)

anova(mod.Rcsz,mod.Rcsz.1)
AIC(mod.Rcsz,mod.Rcsz.1)

mod.Rcsz <- lm(z ~ Yeart -1, data = recr.data)

#Let's refit using lmer

mod.Rcsz.lmer <- lmer(z ~ 1 + (1|Yeart) , data = recr.data)

#quick check

plot(as.numeric(coef(mod.Rcsz)),unlist(coef(mod.Rcsz.lmer)$Yeart))
abline(0,1)



#set up parameter vector with yearly estimates from fixed effects models (lm and glm)
m.par.est <- matrix(NA,nrow=12,ncol=20)
m.par.est[1,] <- coef(mod.Surv)[1:20]
m.par.est[2,] <- coef(mod.Surv)[21:40]
m.par.est[3,] <- coef(mod.Flow)[1:20]
m.par.est[4,] <- coef(mod.Flow)[21]
m.par.est[5,] <- coef(mod.Grow)[1:20]
m.par.est[6,] <- coef(mod.Grow)[21:40]
m.par.est[7,] <- summary(mod.Grow)$sigma
m.par.est[8,] <- coef(mod.Rcsz)[1:20]
m.par.est[9,] <- summary(mod.Rcsz)$sigma
m.par.est[10,] <- 1
m.par.est[11,] <- 2
m.par.est[12,] <- 0.00095

#set up parameter vector with yearly estimates from mixed effects models (lmer and glmer)
m.par.est.mm <- matrix(NA,nrow=12,ncol=20)
m.par.est.mm[1,] <- as.vector(unlist(coef(mod.Surv.glmer.2 )$Yeart["(Intercept)"]))
m.par.est.mm[2,] <- as.vector(unlist(coef(mod.Surv.glmer.2 )$Yeart["z"]))
m.par.est.mm[3,] <- as.vector(unlist(coef(mod.Flow.glmer.1 )$Yeart["(Intercept)"]))
m.par.est.mm[4,] <- as.vector(unlist(coef(mod.Flow.glmer.1 )$Yeart["z"]))
m.par.est.mm[5,] <- as.vector(unlist(coef(mod.Grow.lmer.2)$Yeart["(Intercept)"]))
m.par.est.mm[6,] <- as.vector(unlist(coef(mod.Grow.lmer.2)$Yeart["z"]))
m.par.est.mm[7,] <- as.vector(unlist(summary(mod.Grow.lmer.2)$sigma))
m.par.est.mm[8,] <- as.vector(unlist(coef(mod.Rcsz.lmer)$Yeart["(Intercept)"]))
m.par.est.mm[9,] <- as.vector(unlist(summary(mod.Rcsz.lmer)$sigma))
m.par.est.mm[10,] <- 1
m.par.est.mm[11,] <- 2
m.par.est.mm[12,] <- 0.00095


plot(m.par.est,m.par.est.mm)

source("Carlina Demog Funs DI.R") 

rownames(m.par.est) <- names(m.par.true)
rownames(m.par.est.mm) <- names(m.par.true)

#test correlations between yearly parameters
cor.test(m.par.est[1,],m.par.est[3,])
cor.test(m.par.est[1,],m.par.est[5,])
cor.test(m.par.est[1,],m.par.est[8,])

cor.test(m.par.est[3,],m.par.est[5,])
cor.test(m.par.est[3,],m.par.est[8,])

cor.test(m.par.est["grow.int",],m.par.est["rcsz.int",])
plot(m.par.est["grow.int",],m.par.est["rcsz.int",])
 
 
#####################################################################
#Stochastic perturbation analysis
#####################################################################

nBigMatrix <- 100
n.est <- 20000
n.runin <- 500
minsize <- 1.5
maxsize <- 5
n.years <-20


stoc.pert.analysis<-function(params,n.est,n.runin,C.t,C.t.mean){
	
	year.i <- sample(1:n.years,n.est+1,replace=TRUE)

	K.year.i <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.K<-mk_K(nBigMatrix,params[,i],minsize,maxsize)
		K.year.i[i,,] <- year.K$K
	}

	h <- year.K$h; 
	meshpts <- year.K$meshpts
	
#Calculate mean kernel, v and w

	mean.kernel <- apply(K.year.i,2:3,mean)

	w <- Re(eigen(mean.kernel)$vectors[,1]); 
	v <- Re(eigen(t(mean.kernel))$vectors[,1]);

	# scale eigenvectors <v,w>=1 
	w <- abs(w)/sum(h*abs(w))
	v <- abs(v)
	v <- v/(h*sum(v*w))
    cat(h*sum(v*w)," should = 1","\n")

#Esimate Lambda s
#initialize variables	

	nt<-rep(1/nBigMatrix,nBigMatrix)
	rt.V <- rt.N <- rep(NA,n.est)
	
#Iterate model

	for (year.t in 1:n.est){
		if(year.t%%10000==0) cat("iterate: ", year.t,"\n");

			
		#iterate model with year-specific kernel
		nt1<-K.year.i[year.i[year.t],,] %*% nt
	
		sum.nt1<-sum(nt1)
		
		#Calculate log growth rates  
		
		rt.V[year.t] <- log(sum(nt1*v)/sum(nt*v))
		rt.N[year.t] <- log(sum(nt1)/sum(nt))
		nt <- nt1 / sum.nt1  
	
	}

Ls <- mean(rt.V)
	
	
### Get wt and Rt time series ###
	wt<-matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
	
	for (i in 1:n.est) {
		
		K             <- K.year.i[year.i[i],,]
		wt[i+1,]  <-K %*% wt[i,]
		wt[i+1,]  <-wt[i+1,]/sum(wt[i+1,]);
		if(i%%10000==0) cat("wt ",i,"\n")

	}

	
### Get vt time series ###
	vt<-matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
	for (i in (n.est+1):2) {
		
		K           <- K.year.i[year.i[i],,]
		vt[i-1,]  <- vt[i,] %*% K
		vt[i-1,]  <- vt[i-1,]/sum(vt[i-1,]);
		if(i%%10000==0) cat("vt  ",i,"\n")

	}


elas.s <- rep(0,nBigMatrix)
elas.s.mean <- rep(0,nBigMatrix)

for (year.t in n.runin:(n.est-n.runin)) {

		#standard calculations needed for the various formulae

	
	vt1.C.wt                    <- sapply(1:nBigMatrix,function(z0) sum(vt[year.t+1,] *    
	                                           (C.t[year.i[year.t],,z0]  * wt[year.t,z0])))
	        
	 vt1.C.wt.mean        <- sapply(1:nBigMatrix,function(z0) sum(vt[year.t+1,] *    
	                                           (C.t.mean[year.i[year.t],,z0]  * wt[year.t,z0])))
	
	K           <- K.year.i[year.i[year.t],,]
	
	vt1.K.wt    <- sum(vt[year.t+1,] * (K %*% wt[year.t,]))
	
# # 	vt1.above <- rep(NA,nBigMatrix)
		
# for(z0 in 1:nBigMatrix){
#          pr.pb.c0.G           <- params["p.r",year.i[year.t]] * b_z(meshpts[z0],params[,year.i[year.t]]) *       
#                                                        c_0z1(meshpts,params[,year.i[year.t]]) - 
#                                                       G_z1z(meshpts,meshpts[z0],params[,year.i[year.t]])
#        pb.s.wt                  <-  p_bz(meshpts[z0],params[,year.i[year.t]]) * 
#                                                       s_z(meshpts[z0],params[,year.i[year.t]]) 
#         vt1.above[z0]     <- sum(vt[year.t+1,] * pb.s.wt * (pr.pb.c0.G * wt[year.t,z0])) *h
# }
	



		#calculation of the standard elasticities
	
		elas.s            <-elas.s + (vt1.C.wt) / vt1.K.wt;
		elas.s.mean <-elas.s.mean + (vt1.C.wt.mean) / vt1.K.wt;
		
}

 elas.s            <- elas.s/(n.est-2*n.runin+1)
 elas.s.mean <- elas.s.mean/(n.est-2*n.runin+1)
 
 
 return(list(meshpts=year.K$meshpts, h=h, elas.s=elas.s, elas.s.mean=elas.s.mean, mean.kernel=mean.kernel, Ls=Ls))

}

stoc.pert.analysis.g<-function(params,n.est,n.runin,C.t,C.t.mean){
	
	year.i <- sample(1:n.years,n.est+1,replace=TRUE)

	K.year.i <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.K<-mk_K(nBigMatrix,params[,i],minsize,maxsize)
		K.year.i[i,,] <- year.K$K
	}

	h <- year.K$h; 
	meshpts <- year.K$meshpts
	
#Calculate mean kernel, v and w

	mean.kernel <- apply(K.year.i,2:3,mean)

	w <- Re(eigen(mean.kernel)$vectors[,1]); 
	v <- Re(eigen(t(mean.kernel))$vectors[,1]);

	# scale eigenvectors <v,w>=1 
	w <- abs(w)/sum(h*abs(w))
	v <- abs(v)
	v <- v/(h*sum(v*w))
    cat(h*sum(v*w)," should = 1","\n")

#Esimate Lambda s
#initialize variables	

	nt<-rep(1/nBigMatrix,nBigMatrix)
	rt.V <- rt.N <- rep(NA,n.est)
	
#Iterate model

	for (year.t in 1:n.est){
		if(year.t%%10000==0) cat("iterate: ", year.t,"\n");

			
		#iterate model with year-specific kernel
		nt1<-K.year.i[year.i[year.t],,] %*% nt
	
		sum.nt1<-sum(nt1)
		
		#Calculate log growth rates  
		
		rt.V[year.t] <- log(sum(nt1*v)/sum(nt*v))
		rt.N[year.t] <- log(sum(nt1)/sum(nt))
		nt <- nt1 / sum.nt1  
	
	}

Ls <- mean(rt.V)
	
	
### Get wt and Rt time series ###
	wt<-matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
	
	for (i in 1:n.est) {
		
		K             <- K.year.i[year.i[i],,]
		wt[i+1,]  <-K %*% wt[i,]
		wt[i+1,]  <-wt[i+1,]/sum(wt[i+1,]);
		if(i%%10000==0) cat("wt ",i,"\n")

	}

	
### Get vt time series ###
	vt<-matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
	for (i in (n.est+1):2) {
		
		K           <- K.year.i[year.i[i],,]
		vt[i-1,]  <- vt[i,] %*% K
		vt[i-1,]  <- vt[i-1,]/sum(vt[i-1,]);
		if(i%%10000==0) cat("vt  ",i,"\n")

	}


elas.s <- matrix(0,nBigMatrix,nBigMatrix)
elas.s.2 <- rep(0,nBigMatrix)
elas.s.mean <- matrix(0,nBigMatrix,nBigMatrix)

for (year.t in n.runin:(n.est-n.runin)) {

		#standard calculations needed for the various formulae

	tmp                           <- sapply(1:nBigMatrix,function(z0) sum(vt[year.t+1,] *    
	                                           (C.t[year.i[year.t],,z0]  * wt[year.t,z0])))
	
	vt1.wt                       <- outer(vt[year.t+1,],wt[year.t,],FUN="*")
	vt1.C.wt                    <- vt1.wt * C.t[year.i[year.t],,]  
	
	#cat(all.equal(tmp,apply(vt1.C.wt,2,sum)),"\n")
	        
	 vt1.C.wt.mean        <- vt1.wt * C.t.mean[year.i[year.t],,] 

	
	K           <- K.year.i[year.i[year.t],,]
	
	vt1.K.wt    <- sum(vt[year.t+1,] * (K %*% wt[year.t,]))
	
# # 	vt1.above <- rep(NA,nBigMatrix)
		
# for(z0 in 1:nBigMatrix){
#          pr.pb.c0.G           <- params["p.r",year.i[year.t]] * b_z(meshpts[z0],params[,year.i[year.t]]) *       
#                                                        c_0z1(meshpts,params[,year.i[year.t]]) - 
#                                                       G_z1z(meshpts,meshpts[z0],params[,year.i[year.t]])
#        pb.s.wt                  <-  p_bz(meshpts[z0],params[,year.i[year.t]]) * 
#                                                       s_z(meshpts[z0],params[,year.i[year.t]]) 
#         vt1.above[z0]     <- sum(vt[year.t+1,] * pb.s.wt * (pr.pb.c0.G * wt[year.t,z0])) *h
# }
	



		#calculation of the standard elasticities
	
		elas.s            <-elas.s + (vt1.C.wt) / vt1.K.wt;
		elas.s.2           <-elas.s.2 + (tmp) / vt1.K.wt;
		elas.s.mean <-elas.s.mean + (vt1.C.wt.mean) / vt1.K.wt;
		cat(max(apply(elas.s,2,sum)-elas.s.2),"\n")
}

 elas.s            <- elas.s/(n.est-2*n.runin+1)
 elas.s.mean <- elas.s.mean/(n.est-2*n.runin+1)
 
 
 return(list(meshpts=year.K$meshpts, h=h, elas.s=elas.s, elas.s.mean=elas.s.mean, mean.kernel=mean.kernel, Ls=Ls))

}



########################################################################
#Let's do the probability of flowering function
########################################################################

#Select the parameters to use
params.to.use <- m.par.est

#Calculate meshpts and h for evaluating the perturbation kernels
year.K      <-  mk_K(nBigMatrix,params.to.use[,1],minsize,maxsize)
meshpts <-  year.K$meshpts
h              <-  year.K$h

#First calculate the mean function and perturbation kernels

p_bz.mean <- 0

for(i in 1:n.years){
	p_bz.mean <- p_bz.mean + p_bz(meshpts, params.to.use[,i])
}

p_bz.mean <- p_bz.mean/n.years

Ct_z1z <- function(z1,z,m.par){
		return( p_bz(z, m.par) * s_z(z, m.par) *
				 ( m.par["p.r"] * b_z(z, m.par) * c_0z1(z1, m.par) - G_z1z(z1, z, m.par)) )
	 }
	
C.pert <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.C <-h * (outer(meshpts, meshpts, Ct_z1z, m.par = params.to.use[,i]))
		C.pert[i,,] <- year.C
	}

Ct_z1z.pb.mean <- function(z1,z,m.par){
		return( p_bz.mean * s_z(z, m.par) *
				  ( m.par["p.r"] * b_z(z, m.par) * c_0z1(z1, m.par) - G_z1z(z1, z, m.par)) )
	}

C.pert.mean <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.C <-h * (outer(meshpts, meshpts, Ct_z1z.pb.mean, m.par = params.to.use[,i]))
		C.pert.mean[i,,] <- year.C
	}

pert.K <- stoc.pert.analysis(params.to.use, n.est, n.runin, C.pert, C.pert.mean)
pert.K.g <- stoc.pert.analysis.g(params.to.use, n.est, n.runin, C.pert, C.pert.mean)


meshpts <- pert.K$meshpts
elas.s.sd <- pert.K$elas.s - pert.K$elas.s.mean
sens.mean <- pert.K$elas.s.mean * pert.K$Ls / p_bz.mean
set_graph_pars("panel4")
plot(meshpts,pert.K$elas.s,type="l",xlab="Size (t), z",ylab=expression(e[S] ^p[b]))
add_panel_label("a")
plot(meshpts,pert.K$elas.s.mean,type="l",xlab="Size (t), z",ylab=expression(e[S] ^{p[b]*","*mu}))
add_panel_label("b")
plot(meshpts,elas.s.sd,type="l",xlab="Size (t), z",ylab=expression(e[S] ^{p[b]*","*sigma}))
add_panel_label("c")
plot(meshpts,sens.mean,type="l",xlab="Size (t), z",ylab=expression(s[S] ^{p[b]*","*mu}))
add_panel_label("d")
dev.copy2eps(file="~/Repos/ipm_book/c7/figures/CarlinapbElasSens.eps")


########################################################################
#Let's do the survival function
########################################################################

#First calculate the mean function and perturbation kernels

s.zmean <- 0

for(i in 1:n.years){
	s.zmean <- s.zmean + s_z(meshpts, params.to.use[,i])
}

s.zmean <- s.zmean/n.years

Ct_z1z <- function(z1,z,m.par){
		return( s_z(z, m.par) * (1- p_bz(z, m.par) )*G_z1z(z1, z, m.par) +
		              s_z(z, m.par) * p_bz(z, m.par) * m.par["p.r"] * b_z(z, m.par) * c_0z1(z1, m.par) ) 
	}
	
C.pert <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.C <-h * (outer(meshpts, meshpts, Ct_z1z, m.par = params.to.use[,i]))
		C.pert[i,,] <- year.C
	}

Ct_z1z.s.mean <- function(z1,z,m.par){
		return( s.zmean * (1- p_bz(z, m.par) )*G_z1z(z1, z, m.par) +
		              s.zmean * p_bz(z, m.par) * m.par["p.r"] * b_z(z, m.par) * c_0z1(z1, m.par) ) 
	}


C.pert.mean <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.C <-h * (outer(meshpts, meshpts, Ct_z1z.s.mean, m.par = params.to.use[,i]))
		C.pert.mean[i,,] <- year.C
	}

pert.K <- stoc.pert.analysis(params.to.use, n.est, n.runin, C.pert, C.pert.mean)
pert.K.g <- stoc.pert.analysis.g(params.to.use, n.est, n.runin, C.pert, C.pert.mean)
#Check sum elasticities is 1

cat(sum(pert.K$elas.s)," should be 1","\n")
cat(sum(pert.K.g$elas.s)," should be 1","\n")


meshpts <- pert.K$meshpts
elas.s.sd <- pert.K$elas.s - pert.K$elas.s.mean
sens.mean <- pert.K$elas.s.mean * pert.K$Ls / s.zmean
set_graph_pars("panel4")
plot(meshpts,pert.K$elas.s,type="l",xlab="Size (t), z",ylab=expression(e[S] ^s(z)))
add_panel_label("a")
plot(meshpts,pert.K$elas.s.mean,type="l",xlab="Size (t), z",ylab=expression(e[S] ^{s(z)*","*mu}))
add_panel_label("b")
plot(meshpts,elas.s.sd,type="l",xlab="Size (t), z",ylab=expression(e[S] ^{s(z)*","*sigma}))
add_panel_label("c")
plot(meshpts,sens.mean,type="l",xlab="Size (t), z",ylab=expression(s[S] ^{s(z)*","*mu}))
add_panel_label("d")

dev.copy2eps(file="~/Repos/ipm_book/c7/figures/CarlinasElasSens.eps")	
	
########################################################################
#Let's do the growth function
########################################################################

#First calculate the mean function and perturbation kernels

G.mean <- 0

for(i in 1:n.years){
	G.mean <- G.mean + outer(meshpts, meshpts, G_z1z, m.par = params.to.use[,i])
}

G.mean <- G.mean/n.years

Ct_z1z <- function(z1,z,m.par){
		return( s_z(z, m.par) * (1- p_bz(z, m.par) )*G_z1z(z1, z, m.par)  ) 
	}
	
C.pert <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.C <-h * (outer(meshpts, meshpts, Ct_z1z, m.par = params.to.use[,i]))
		C.pert[i,,] <- year.C
	}

Ct_z1z.s.mean <- function(z1,z,m.par){
		return( s_z(z, m.par)  * (1- p_bz(z, m.par) ) * G.mean) 
	}


C.pert.mean <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.C <-h * (outer(meshpts, meshpts, Ct_z1z.s.mean, m.par = params.to.use[,i]))
		C.pert.mean[i,,] <- year.C
	}

stoc.pert.analysis<-function(params,n.est,n.runin,C.t,C.t.mean){
	
	year.i <- sample(1:n.years,n.est+1,replace=TRUE)

	K.year.i <- array(NA,c(n.years,nBigMatrix,nBigMatrix))
	
	for(i in 1:n.years){
		year.K<-mk_K(nBigMatrix,params[,i],minsize,maxsize)
		K.year.i[i,,] <- year.K$K
	}

	h <- year.K$h; 
	meshpts <- year.K$meshpts
	
#Calculate mean kernel, v and w

	mean.kernel <- apply(K.year.i,2:3,mean)

	w <- Re(eigen(mean.kernel)$vectors[,1]); 
	v <- Re(eigen(t(mean.kernel))$vectors[,1]);

	# scale eigenvectors <v,w>=1 
	w <- abs(w)/sum(h*abs(w))
	v <- abs(v)
	v <- v/(h*sum(v*w))
    cat(h*sum(v*w)," should = 1","\n")

#Esimate Lambda s
#initialize variables	

	nt<-rep(1/nBigMatrix,nBigMatrix)
	rt.V <- rt.N <- rep(NA,n.est)
	
#Iterate model

	for (year.t in 1:n.est){
		if(year.t%%10000==0) cat("iterate: ", year.t,"\n");

			
		#iterate model with year-specific kernel
		nt1<-K.year.i[year.i[year.t],,] %*% nt
	
		sum.nt1<-sum(nt1)
		
		#Calculate log growth rates  
		
		rt.V[year.t] <- log(sum(nt1*v)/sum(nt*v))
		rt.N[year.t] <- log(sum(nt1)/sum(nt))
		nt <- nt1 / sum.nt1  
	
	}

Ls <- mean(rt.V)
	
	
### Get wt and Rt time series ###
	wt<-matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
	
	for (i in 1:n.est) {
		
		K             <- K.year.i[year.i[i],,]
		wt[i+1,]  <-K %*% wt[i,]
		wt[i+1,]  <-wt[i+1,]/sum(wt[i+1,]);
		if(i%%10000==0) cat("wt ",i,"\n")

	}

	
### Get vt time series ###
	vt<-matrix(1/nBigMatrix, nrow=n.est+1, ncol=nBigMatrix);
	for (i in (n.est+1):2) {
		
		K           <- K.year.i[year.i[i],,]
		vt[i-1,]  <- vt[i,] %*% K
		vt[i-1,]  <- vt[i-1,]/sum(vt[i-1,]);
		if(i%%10000==0) cat("vt  ",i,"\n")

	}


elas.s <- matrix(0,nBigMatrix,nBigMatrix)
elas.s.mean <- matrix(0,nBigMatrix,nBigMatrix)

for (year.t in n.runin:(n.est-n.runin)) {

		#standard calculations needed for the various formulae

	vt1.wt                       <- outer(vt[year.t+1,],wt[year.t,],FUN="*")
	vt1.C.wt                    <- vt1.wt * C.t[year.i[year.t],,]  
	        
	 vt1.C.wt.mean        <- vt1.wt * C.t.mean[year.i[year.t],,] 
	
	K           <- K.year.i[year.i[year.t],,]
	
	vt1.K.wt    <- sum(vt[year.t+1,] * (K %*% wt[year.t,]))

		#calculation of the standard elasticities
	
		elas.s            <-elas.s + (vt1.C.wt) / vt1.K.wt;
		elas.s.mean <-elas.s.mean + (vt1.C.wt.mean) / vt1.K.wt;
		
}

 elas.s            <- elas.s/(n.est-2*n.runin+1)
 elas.s.mean <- elas.s.mean/(n.est-2*n.runin+1)
 
 
 return(list(meshpts=year.K$meshpts, h=h, elas.s=elas.s, elas.s.mean=elas.s.mean, mean.kernel=mean.kernel, Ls=Ls))

}

pert.K <- stoc.pert.analysis(params.to.use, n.est, n.runin, C.pert, C.pert.mean)

meshpts <- pert.K$meshpts
elas.s.sd <- pert.K$elas.s - pert.K$elas.s.mean
sens.mean <- pert.K$elas.s.mean * pert.K$Ls / G.mean

## set up the plots
ikeep <- ikeep <- which(meshpts>1.5 & meshpts<5) # use to extract a region to plot
set_graph_pars("panel4")
## plot the growth sensitivity and elasticity surfaces
image(meshpts[ikeep], meshpts[ikeep], t(pert.K$elas.s[ikeep,ikeep]),
      col=grey(seq(0.6, 1, length=100)),
      xlab="Size (t), z", ylab="Size (t+1), z\'")
contour(meshpts[ikeep], meshpts[ikeep], t(pert.K$elas.s[ikeep,ikeep]), 
        add=TRUE)
add_panel_label("a")
## plot the offspring size kernel sensitivity and elasticity surfaces
image(meshpts[ikeep], meshpts[ikeep], t(pert.K$elas.s.mean[ikeep,ikeep]),
      col=grey(seq(0.6, 1, length=100)),
      xlab="Size (t), z", ylab="Size (t+1), z\'")
contour(meshpts[ikeep], meshpts[ikeep], t(pert.K$elas.s.mean[ikeep,ikeep]), add=TRUE)
add_panel_label("b")
image(meshpts[ikeep], meshpts[ikeep], t(elas.s.sd [ikeep,ikeep]),
      col=grey(seq(0.6, 1, length=100)),
      xlab="Size (t), z", ylab="Size (t+1), z\'")
contour(meshpts[ikeep], meshpts[ikeep], t(elas.s.sd [ikeep,ikeep]), add=TRUE)
add_panel_label("c")
image(meshpts[ikeep], meshpts[ikeep], t(sens.mean[ikeep,ikeep]),
      col=grey(seq(0.6, 1, length=100)),
      xlab="Size (t), z", ylab="Size (t+1), z\'")
contour(meshpts[ikeep], meshpts[ikeep], t(sens.mean[ikeep,ikeep]), add=TRUE)
add_panel_label("d")

dev.copy2eps(file="~/Repos/ipm_book/c7/figures/CarlinaGElasSens.eps")	




